{
  "name": "guthrie",
  "description": "A Node.js MVC framework built on Express.js, inspired by Microsoft's ASP.NET MVC.",
  "keywords": [
    "guthrie",
    "mvc",
    "framework",
    "web",
    "express",
    "asp.net",
    "microsoft"
  ],
  "version": "0.2.0",
  "author": {
    "name": "Dominic Pettifer",
    "email": "sironfoot@gmail.com"
  },
  "contributors": [],
  "dependencies": {
    "express": "3.x"
  },
  "devDependencies": {
    "mocha": "*",
    "ejs": "*",
    "nunjucks": "*"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/Sironfoot/guthrie.js.git"
  },
  "license": "MIT",
  "main": "index",
  "readme": "guthrie.js\n==========\n\nA Node.js MVC framework built on Express.js, inspired by Microsoft's ASP.NET MVC.\n\nGuthrie organises your code into controllers and actions and supports filters and events. You can think of a controller\nas nouns for something (product, category, order) and actions as verbs (show, edit, remove).\n\n## Installation\n\n    $ npm install express\n    $ npm install guthrie\n\n## Quick Start\n\nAdd it to an existing Express.js app:\n\n````javascript\nvar express = require('express');\nvar gu = require('guthrie');\n\nvar app = express();\n//... insert middleware\napp.use(app.router);\n\nvar router = new gu.Router(app, __dirname);\n\nrouter.mapRoute('/', {\n    controller: 'home',\n    action: 'index'\n});\n\nrouter.mapRoute('/product/:id/:name', {\n    controller: 'product',\n    action: 'detail'\n});\n\nhttp.createServer(app).listen(3000);\n````\n\nThis will create routes for two controllers, 'home' and 'product'. Each can have one\nor more 'actions'. For instance, we have mapped the '/' path to the 'home' controller and the 'index' action.\n\nBy convension, controllers must appear in the '/controllers' directory in your app's\nroot directory, and the file name must be affixed with 'Controller.js'. So lets create a 'homeController.js' file in the\n'/controllers' directory.\n\n````javascript\nvar gu = require('guthrie');\n\nvar homeController = gu.controller.create();\nhomeController.actions = {\n    \n    // PATH: /\n    index: {\n        GET: function(req, res) {\n            res.view();\n        }\n    }\n};\n\nmodule.exports = homeController;\n````\n\nres.view() is a helper method that works the same as res.render(), except it assumes the view is located in\n'/views/controllerName/actionName'. So in our above example, it will look for '/views/home/index.html'.\n\nWe're also creating a GET function for a GET request, but POST, PUT, and DELETE are also supported.\n\n## More on Routes\n\nWhen defining routes you can include the controller and action as parameters within the route itself:\n\n    router.mapRoute('/product/:action/:id', { controller: 'product' });\n\nSo the URL '/product/edit/123' will match the 'product' controller and the 'edit' action. In fact the pattern\n'/controller/action/id' is a common one so you can simply define one route to cover all your controllers/actions with:\n\n    router.mapRoute('/:controller/:action?/:id?');\n\nNotice the question mark on action indicating that it's optional. The action name will default to 'index', so the\nURL '/product' will map to the 'index' action in the 'product' controller.\n\n**WARNING**: By default, express(1) puts the router middleware before the static middleware, so the above route will\nmatch all your scripts and stylesheets, so remember to change the order:\n\n    app.use(express.static(path.join(__dirname, 'public')));\n    app.use(app.router);\n\n## Action Filters\n\nAction Filters provide reusable functionality for common tasks (checking authorisation for instance).\nThey can be placed on controllers and will run for all actions in that controller, or on individual\nactions. To place on a controller:\n\n````javascript\nvar accountController = gu.controller.create({\n    filters: [ filters.mustBeLoggedIn ]\n});\n````\n\nTo place on an individual action:\n\n````javascript\nvar accountController = gu.controller.create();\naccountController.actions = {\n    \n    // PATH: /account/login\n    login: {\n        GET: function(req, res) {\n            res.view();\n        }\n    }\n    \n    // PATH: /account/orders\n    orders: {\n        filters: [ filters.mustBeLoggedIn ],\n        \n        GET: function(req, res) {\n            res.view();\n        }\n    }\n};\n````\n\nLets look at the implentation for 'mustBeLoggedIn':\n\n````javascript\nexports.mustBeLoggedIn = function(req, res, next) {\n    \n    if (!res.session.loggedInUser) {\n        res.redirect('/account/login');\n    }\n    else {\n        next();\n    }\n};\n````\n\nFilters work just like connect middleware. You can define multiple filters per controller and action.\nThey will be executed in series and before any actions are run. Because they are called one after the other,\nyou must remember to call the next() function to indicate that the next filter should run, unless you want to\nstop processing at that point and send a result to the browser (see the res.redirect() example above).\n\n\n## Events\n\nControllers support 4 standard events:\n\n* actionExecuting - called before any action is executed\n* actionExecuted - called after any action is executed\n* resultExecuting - called before the result is executed\n* resultExecuted - called after the result is executed\n\nA 'result' is defined as any method on the HttpResponse object that sends a result to the browser,\nfor instance res.end(), res.render(), res.view(), res.redirect() etc.\n\n````javascript\nvar homeController = gu.controller.create();\n\nhomeController.on('actionExecuting', function(req, res, next) {\n    // Do something for all actions in the home controller\n    next();\n});\n````\n\nLike Filters, Events also behave like Connect middleware and are called in series, so remember to call next().\n\n\n## Controller Inheritance\n\nYou can create a base controller, and have all other controllers inherit from it.\n\n````javascript\nvar baseController = new gu.controller.create();\nmodule.exports = baseController;\n````\n\n````javascript\nvar baseController = require('./baseController');\n\nvar homeController = new gu.controller.inherit(baseController, {\n    filters: [ /* optional filters */ ]\n});\n````\n\nController inheritance is useful for defining Events and Filters that run for all controllers/actions in the\napplication. For instance, it's common for a web app to have a base/root layout template (or partial views) that contains\nsome form of database derived html output repeated for every page in the website. An ecommerce app might have a list of\ncategories on the left side in every page for instance. Rather than repeat the categories data access code in every action,\nyou could put it in the base controller:\n\n````javascript\nvar baseController = new gu.controller.create();\n\nbaseController.on('actionExecuting', function(req, res, next) {\n    db.getCategories(function(err, categories) {\n        if (err) throw err;\n    \n        res.locals.categories = categories;\n        next();\n    });\n});\n\nmodule.exports = baseController;\n````\n\nIf you ensure every controller inherits from base controller, every template in the web application\nwill have a categories property pre-populated.\n\n## Areas\n\nJust like in ASP.NET MVC, you can further divide up your code base into Areas. Areas are self contained units of functionality with their own set of controllers and views, usually accessible via a URL affix (e.g. /admin).\n\nSet-up an area in your app.js entry point:\n\n````javascript\nvar router = new gu.Router(app, __dirname);\n\nvar adminArea = router.createArea('admin');\nadminArea.mapRoute('/admin', { controller: 'home', action: 'index' });\nadminArea.mapRoute('/admin/:controller/:action?/:id?');\n\n// normal routes here (snip)...\n````\n\nWe have defined an 'admin' area. By convention, guthrie.js will look for an /admin folder inside an /areas directory, and expect find a /controllers and /views directory. So your folder structure should look something like this:\n\n* app.js\n* areas\n\t* area1\n\t\t* controllers\n\t\t* views\n\t* area2\n\t\t* controllers\n\t\t* views\n\nControllers are then defined in the normal way. Calling res.view()  will resolve to the correct template in the area's /views folder.\n\n\n## 'this' Context in Filters, Events and Actions\n\nEvery Filter, Event and Action that is run has its 'this' context set to a special context object that persists\nfor the entire running HTTP request. You can assign properties to this context and they will be available in subsequent\nfilters/events/actions:\n\n````javascript\nhomeController.on('actionExecuting', function(req, res, next) {\n    this.user = 'Scott Guthrie';\n    next();\n});\n\nhomeController.actions = {\n    index: {\n        filters: [\n            function(req, res, next) {\n                this.clothing = 'Red polo shirt'\n                next();\n            }\n        ],\n        GET: function(req, res, next) {\n            console.log(this.user); // Outputs 'Scott Guthrie'\n            console.log(this.clothing); // Outputs 'Red polo shirt'\n            \n            res.end();\n        }\n    }\n};\n````\n\nThe 'this' context also has a couple of helpful properties available:\n\n* this.app - returns the Express app instance for this request\n* this.viewbag() - helper function to attach properties to locals in templates\n\nThe above viewbag() function could be called like so:\n\n    this.viewbag().user = 'Scott Guthrie';\n\n...and in a view/template:\n\n    <p class=\"user\"><%= viewbag.user %></p>\n\n\n## Sample E-commerce App\n\nLocated in /examples/ecommerce in this git repository, you'll find a sample ecommerce application implemented using express and guthrie.js.\n\n\n## Coming Soon\n\n* Web.config files\n* Model Validation (maybe)\n\n\n## About the name\n\nguthrie.js is named after Scott Guthrie who is the corporate vice president of the Microsoft Developer Division. He created the original ASP.NET MVC in Februrary 2007 while flying on plane to a conference on the East Coast of the USA.\n\n\n## License \n\n(The MIT License)\n\nCopyright (c) 2013 Dominic Pettifer &lt;sironfoot@gmail.com&gt;\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n'Software'), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n",
  "readmeFilename": "README.md",
  "_id": "guthrie@0.2.0",
  "_from": "guthrie@"
}
